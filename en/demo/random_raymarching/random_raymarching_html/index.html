<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Solve PDE with Random Raymarching</title>

    <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css"/>
    <link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css"/>
    <link rel="stylesheet" href="../css/hint.min.css"/>
    <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css"/>


    <!-- 主题依赖的图标库，不要自行修改 -->

    <link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_pf9vaxs7x7b.css">
    <link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">
    <link rel="stylesheet" type="text/css" href="../css/main.css"/>
    <script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
    <script src="../js/header.js"></script>

    <style>
        body {
            /*overflow-y: auto;*/
        }

        canvas {
            display: block;
            margin: 10px;
        }

        #container {
            display: grid;
            margin-top: 30px;
            margin-bottom: 20px;
            padding-top: 20px;
            grid-template-columns: 1fr 3.9fr 1.3fr;
            grid-template-rows: 1fr 3fr;
            grid-template-areas: "stat    main control_area" "hue_bar main control_area";
            justify-items: center;
            align-content: center;
            column-gap: 4px
        }

        .item-1 {
            grid-area: stat;
        }

        .item-2 {
            grid-area: hue_bar;
            align-self: start;
            visibility: hidden;
        }

        .item-3 {
            grid-area: main;
            overflow: auto;
            max-width: 100%;
        }

        .item-4 {
            grid-area: control_area;
        }

        #slider_cutting {
            min-height: 28px;
        }

        #cuttingPlaneText {
            height: 24px;
            width: 48px;
            font-size: 17px;
            margin-left: -8px;
        }

        #slider_container {
            display: grid;
            grid-template-columns: 1fr 0.5fr;
            grid-template-rows: repeat(6, 1fr);
            grid-template-areas: "rtext rtext" "rslider rvalue" "mtext mtext" "mslider mvalue" "stext stext" "sslider svalue";
            row-gap: 5px;
        }

        #baseColor{
            display: flex;
            justify-content: flex-start;
            align-items: center;
        }

        #baseColorText{
            text-align:center;
        }

        #colorPicker{
            height: 30px;
            width: 60px;
            padding: 0px;
        }

        .slider-text-1 {
            grid-area: rtext;
        }

        .slider-text-2 {
            grid-area: mtext;
            /*justify-self: center;*/
        }

        .slider-text-3 {
            grid-area: stext;
            /*justify-self: center;*/
        }

        .slider-value-box {
            margin-top: -4px;
        }

        .slider_value {
            height: 24px;
            width: 42px;
            font-size: 17px;
        }

        .item{
            margin-left: 10px;
        }

        .subTitle{
            display:block;
            font-size: 18px;
            margin-bottom: 6px;
        }
    </style>
</head>
<body>

<header id ="header1" style="height: 9vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
        <div class="container">
            <a class="navbar-brand"
               href="/">&nbsp;<strong>Topos Cat</strong>&nbsp;</a>

            <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
                    data-target="#navbarSupportedContent"
                    aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
                <div class="animated-icon"><span></span><span></span><span></span></div>
            </button>

            <!-- Collapsible content -->
            <div class="collapse navbar-collapse" id="navbarSupportedContent">
                <ul class="navbar-nav ml-auto text-center">


                    <li class="nav-item">
                        <a class="nav-link" href="/">
                            <i class="iconfont icon-home-fill"></i>
                            Home
                        </a>
                    </li>


                    <li class="nav-item">
                        <a class="nav-link" href="/archives/">
                            <i class="iconfont icon-archive-fill"></i>
                            Archives
                        </a>
                    </li>


                    <li class="nav-item">
                        <a class="nav-link" href="/categories/">
                            <i class="iconfont icon-category-fill"></i>
                            Categories
                        </a>
                    </li>


                    <li class="nav-item">
                        <a class="nav-link" href="/tags/">
                            <i class="iconfont icon-tags-fill"></i>
                            Tags
                        </a>
                    </li>


                    <li class="nav-item">
                        <a class="nav-link" href="/demo/">
                            <i class="iconfont icon-exp-fill"></i>
                            Demo
                        </a>
                    </li>


                    <li class="nav-item">
                        <a class="nav-link" href="/about/">
                            <i class="iconfont icon-user-fill"></i>
                            About
                        </a>
                    </li>

                    <li class="nav-item">
                        <a class="nav-link" href="/links/">
                            <i class="iconfont icon-link-fill"></i>
                            Link
                        </a>
                    </li>


                    <li class="nav-item" id="search-btn">
                        <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                                class="iconfont icon-search"></i>&nbsp;</a>
                    </li>

                    <li class="nav-item" id="color-toggle-btn">
                        <a class="nav-link" href="javascript:">&nbsp;<i
                                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
                    </li>

                </ul>
            </div>
        </div>
    </nav>

        <div class="banner intro-2" id="background" parallax=true
             style="background: url('../src/banner.png') no-repeat center center;
               background-size: cover;">
            <div class="full-bg-img">
                <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
                    <div class="container page-header text-center fade-in-up">
                        <span class="h2" id="subtitle"></span>
                    </div>
                </div>
            </div>
        </div>
</header>

<div id="container">
    <div id="stats" class="item-1">

    </div>
    <div id="hue" class="item-2">
        <div id="Marching_Number">
            <b>Marching Number</b>
            <br/>
        </div>
        <div id="hue_container">
            <div class="hue-1">
                <br/>
                <div style="height: 40px"></div>
            </div>
            <div class="hue-2">256</div>
            <div class="hue-3">192</div>
            <div class="hue-3">128</div>
            <div class="hue-4">64</div>
            <div class="hue-5">1</div>
        </div>
    </div>
    <div class="item-3">
        <canvas id="triangle" width="900" height="600"></canvas>
    </div>
    <div class="item-4">
        <b class="subTitle">Settings</b>
        <div class="item">
            <div id="slider_cutting"> Cutting Plane</div>
            <label for="cuttingPlaneSlider"></label>
            <input type="range" id="cuttingPlaneSlider" min="-0.6" max="0.6" step="0.01" value="0.3"/>
            &ensp;
            <label for="cuttingPlaneText"></label>
            <input type="text" id="cuttingPlaneText" value="0.3">
            <br/>
            <input type="checkbox" id="animate"><label for="animate"> Animate</label>
            <br/>
            <input type="checkbox" id="stat" checked="checked"><label for="stat"> Show Statistics</label>
            <br/><br/>
        </div>
        <b class="subTitle">Pass</b>
        <div class="item">
            <input type="checkbox" id="diffuse" checked="checked"><label for="diffuse"> Diffuse</label>
            <br/>
            <input type="checkbox" id="specular" checked="checked"><label for="specular"> Specular</label>
            <br/>
            <input type="checkbox" id="shadow" checked="checked"><label for="shadow"> Shadow</label>
            <br/><br/>
        </div>
        <b class="subTitle">Material</b>
        <div class="item">
            <div id="baseColor">
                <div id="baseColorText">Base Color</div> &ensp;&ensp;<label for="colorPicker"></label>
                <input type="color" id="colorPicker" value="#FFFF48"/>
            </div>
            <br/>
            <div id="slider_container">
                <div class="slider-text-1"> Roughness</div>
                <div>
                    <label for="sRoughness"></label>
                    <input type="range" id="sRoughness" min="0.0" max="1.0" step="0.01" value="0.3"/>
                </div>
                <div class="slider-value-box">
                    <label for="vRoughness"></label>
                    <input type="text" id="vRoughness" value="0.3" class="slider_value">
                </div>
                <div class="slider-text-2"> Metalness</div>
                <div>
                    <label for="sMetalness"></label>
                    <input type="range" id="sMetalness" min="0.0" max="1.0" step="0.01" value="0"/>
                </div>
                <div class="slider-value-box">
                    <label for="vMetalness"></label>
                    <input type="text" id="vMetalness" value="0" class="slider_value">
                </div>
                <div class="slider-text-3"> Specular</div>
                <div>
                    <label for="sSpecular"></label>
                    <input type="range" id="sSpecular" min="0.0" max="1.0" step="0.01" value="0.5"/>
                </div>
                <div class="slider-value-box">
                    <label for="vSpecular"></label>
                    <input type="text" id="vSpecular" value="0.5" class="slider_value">
                </div>
            </div>
        </div>
        <br/><br/>
        <div style="width: 230px"></div>
    </div>
</div>


<script type="text/javascript" src="../lib/webgl-utils.js"></script>
<script type="text/javascript" src="../lib/shader-util.js"></script>
<script type="text/javascript" src="../lib/webgl_point4.js"></script>
<script type="text/javascript" src="../lib/webgl_vector3.js"></script>
<script type="text/javascript" src="../lib/webgl_matrix.js"></script>
<script type="text/javascript" src="../lib/stat.js"></script>

<script id="vertex-shader" type="x-shader/x-vertex">#version 300 es
precision highp float;

//uniform float u_aspectRatio;
in vec2 a_position;
out vec2 v_position;

void main() {
    v_position = a_position;
    gl_Position = vec4(a_position, 0, 1);
}
</script>

<script id="fragment-shader-frame-buffer" type="x-shader/x-fragment">#version 300 es
precision highp float;

// 常量定义

#define HEIGHT 600.
#define NB_LIGHTS 2
#define MATERIAL_N 2

#define MAX_MARCHING_STEPS 512// 最大raymarching次数
#define MIN_DIST 0.0// 起始raymarching距离
#define MAX_DIST 50.0// 最远raymarching距离
#define EPSILON 0.0001// raymarching停止距离
#define MIN_SHADOW_DIST 0.01
#define MAX_SHADOW_DIST 30.0
#define WOS_MARCH_ITERATIONS 80

#define AMBIENT_ALBEDO 0.05


#define PI 3.1415926535
#define EPS 1e-8
#define UPPER 0.9999

uniform int u_drawN;
uniform int u_diffusePassOn;
uniform int u_specularPassOn;
uniform int u_shadowPassOn;
uniform mat3 u_trans_cam;
uniform float u_rotZAngle;
uniform float u_aspectRatio;
uniform float u_cam_w;
uniform vec3 u_eye;
uniform vec3 u_baseColor[MATERIAL_N];
uniform float u_metalness[MATERIAL_N];
uniform float u_roughness[MATERIAL_N];
uniform float u_specular[MATERIAL_N];
uniform float u_widthHeight[2];
uniform float u_cuttingPlane;
uniform sampler2D samplerFB;
in vec2 v_position;
out vec4 outputColor;

struct Light {
    vec3 pos;
    vec3 color;
};
Light lights[NB_LIGHTS];

struct PointInfo{
    float sd;// signed distance
    int materialID;
};

vec3 hsv2rgb(vec3 c){
    vec4 K=vec4(1., 2./3., 1./3., 3.);
    return c.z*mix(K.xxx, clamp(abs(fract(c.x+K.xyz)*6.-K.w)-K.x, 0., 1.), c.y);
}

mat3 rotationZ(float angle) {
    return mat3(cos(angle), -sin(angle), 0.,
    sin(angle), cos(angle), 0.,
    0., 0., 1.);
}

vec3 rgb2hsv(vec3 c) {
    float cMax=max(max(c.r, c.g), c.b),
    cMin=min(min(c.r, c.g), c.b),
    delta=cMax-cMin;
    vec3 hsv=vec3(0., 0., cMax);
    if (cMax>cMin){
        hsv.y=delta/cMax;
        if (c.r==cMax){
            hsv.x=(c.g-c.b)/delta;
        }
        else if (c.g==cMax){
            hsv.x=2.+(c.b-c.r)/delta;
        }
        else {
            hsv.x=4.+(c.r-c.g)/delta;
        }
        hsv.x=fract(hsv.x/6.);
    }
    return hsv;
}

float planeSDF(vec3 p, vec3 n, float h)
{
    return dot(p, n) + h;
}

float torusSDF(vec3 p, vec2 t)
{
    vec2 q = vec2(length(p.xz)-t.x, p.y);
    return length(q)-t.y;
}

float boxSDF(vec3 p, vec3 b)
{
    vec3 q = abs(p) - b;
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

float opSmoothUnion(float d1, float d2, float k)
{
    float h = max(k-abs(d1-d2), 0.0);
    return min(d1, d2) - h*h*0.25/k;
}

PointInfo opUnion(PointInfo d1, PointInfo d2) {
    if (d1.sd < d2.sd){
        return d1;
    }
    else {
        return d2;
    }
}

PointInfo opDiff(PointInfo d1, PointInfo d2) {
    if (-d1.sd>=d2.sd){
        return PointInfo(-d1.sd, d1.materialID);
    }
    else {
        return PointInfo(d2.sd, d2.materialID);
    }
}

PointInfo SDF[4];

float interiorMap(vec3 p){
    vec3 rp = rotationZ(u_rotZAngle) * p;
    SDF[0] = PointInfo(torusSDF(rp - vec3(-0.5, 0., 0.), vec2(0.4, 0.19)), 0);
    SDF[1] = PointInfo(torusSDF(rp.xzy - vec3(0.5, 0., 0.), vec2(0.4, 0.19)), 0);
    return opSmoothUnion(SDF[0].sd, SDF[1].sd, 0.25);
}

PointInfo sceneMap(vec3 p){
    vec3 rp = rotationZ(u_rotZAngle) * p;
    SDF[2] = PointInfo(planeSDF(rp, vec3(0., 1., 0.), u_cuttingPlane), 2);
    SDF[3] = PointInfo(planeSDF(p, vec3(0., 0., 1.), 0.7), 1);
    return opUnion(opDiff(SDF[2], PointInfo(interiorMap(p), 0)), SDF[3]);
}

PointInfo shortestDistanceToSurface2(vec3 eye, vec3 v, float start, float end, float coff, out float midDepth, out float minThreshold, out int midN){ //v == -marchingDirection
    float depth=start+EPS;
    PointInfo dist;
    float temp = minThreshold;
    int checking = 1;

    for (int i=0; i<MAX_MARCHING_STEPS; i++){
        dist = sceneMap(eye - depth * v);
        if (dist.sd < EPSILON){
            dist.sd = depth;
            return dist;
        }

        else if (checking>0&&dist.sd/(coff * depth)< minThreshold - EPSILON){ //3000 5000 8000
            midDepth = depth;
            midN=i;
            minThreshold = dist.sd/(coff * depth);
            checking = 2;
        }
        else if (checking == 2 && dist.sd/(coff * depth)> minThreshold - EPSILON){
            checking = 0;
        }
        depth+=dist.sd;
        if (depth>=end){
            dist.sd = end;
            return dist;
        }
    }
    dist.sd = end;
    return dist;
}

PointInfo shortestDistanceToSurface(vec3 eye, vec3 v, float start, float end){ //v == -marchingDirection
    float depth=start;
    PointInfo dist;

    for (int i=0; i<MAX_MARCHING_STEPS; i++){
        dist = sceneMap(eye - depth * v);
        if (dist.sd < EPSILON){
            dist.sd = depth;
            return dist;
        }
        depth+=dist.sd;
        if (depth>=end){
            dist.sd = end;
            return dist;
        }
    }
    dist.sd = end;
    return dist;
}

vec3 calcNormal(vec3  p) { // for function f(p)
    const float h = 0.0001;// replace by an appropriate value
    const vec2 k = vec2(1, -1);
    return normalize(k.xyy*sceneMap(p + k.xyy*h).sd +
    k.yyx*sceneMap(p + k.yyx*h).sd +
    k.yxy*sceneMap(p + k.yxy*h).sd +
    k.xxx*sceneMap(p + k.xxx*h).sd);
}

float calcSoftshadow(vec3 ro, vec3 rd, float mint, float tmax)
{
    float res = 1.0;
    float t = mint;
    float ph = 1e10;// big, such that y = 0 on the first iteration

    for (int i=0; i<64; i++)
    {
        float h = sceneMap(ro+rd*t).sd;
        // use this if you are getting artifact on the first iteration, or unroll the
        // first iteration out of the loop
        float y = (i==0) ? 0.0 : h*h/(2.0*ph);
        //            float y = h*h/(2.0*ph);
        float d = sqrt(h*h-y*y);
        res = min(res, 10.0*d/max(EPS, t-y));
        ph = h;
        t += h;
        if (res<0.0001 || t>tmax) break;
    }
    return res;
}

float stripe(vec3 pos) {
    return fract(pos.x * 4.66 + 0.25) > 0.5 ? 1.0 : 0.0;
}

int  seed = 1;
void srand(int s) {
    seed = s;
}

int rand(void) {
    seed = seed * 0x343fd + 0x269ec3;
    return (seed >> 16) & 32767;
}

int hash(int n) {
    n = (n << 13) ^ n;
    return n * (n * n * 15731 + 789221) + 1376312589;
}

// --------------------------------------

vec3 randomOnSphere(void) {
    float theta = (6.283185 / 32767.0) * float(rand());
    float u = (2.0 / 32767.0) * float(rand()) - 1.0;
    return vec3(sqrt(max(0.0, 1.0 - u * u)) * vec2(cos(theta), sin(theta)), u);
}


vec3 march (vec3 p, vec2 screen, out int ii) { //Walk-on-spheres
    float h;
    vec3 pt=p;

    for (int i = 0; i <36; i++) {
        ii =i;
        h = -interiorMap(pt);
        if (h < 0.001) return pt;
        pt = pt + h * randomOnSphere();
    }
    ii = -1;
    return vec3(0.);
}


const vec3 color2 = vec3(0.03, 0.02, 0.2);
vec3 hsvColorscale (vec3 color1, vec3 color2, float x) {
    vec3 c1 = rgb2hsv(1.0 - color1);
    vec3 c2 = rgb2hsv(1.0 - color2);
    return 1.0 - hsv2rgb(mix(c1, c2, x));
}

vec3 objectPBRLighting (Light light, vec3 p, vec3 v, vec3 n, int mID, vec2 screen){

    vec3 baseColor;
    float metalness, roughness, specular;
    float shadowPass = 1.;

    if (mID == 0){
        baseColor = mix(u_baseColor[0], color2, stripe(p));
        metalness = u_metalness[0];
        roughness = u_roughness[0];
        specular = u_specular[0];
    }
    else if (mID == 1){
        baseColor = u_baseColor[1];
        metalness = u_metalness[1];
        roughness = u_roughness[1];
        specular = u_specular[1];
    }
    else {
        float sum = 0.0;
        int sumN = 24;
        for (int i = 0; i <sumN; i++) {
            int ii = 0;
            sum += stripe(march(p, screen, ii));
            if (ii == -1){
                sumN--;
            }
        }
        if (sumN > 0)
        sum /= float(sumN);
        baseColor = hsvColorscale(u_baseColor[0], vec3(0.03, 0.02, 0.2), sum);
        metalness = u_metalness[0];
        roughness = u_roughness[0];
        specular = u_specular[0];
    }

    float falloffLength = dot(light.pos - p, light.pos - p);
    vec3 l = (light.pos - p)/sqrt(falloffLength);//vector from sample point to light
    vec3 h = normalize(v + l);//normal vector of the microface at the sample point
    float a = roughness * roughness;
    float dotNL = clamp (dot (n, l), EPS, UPPER);
    float dotNV = clamp (dot (n, v), EPS, UPPER);
    float dotNH = clamp (dot (n, h), EPS, UPPER);
    float dotHV = clamp (dot (l, h), EPS, UPPER);

    float d = (dotNH * a * a - dotNH) * dotNH + 1.;
    float D = a * a / (PI * d * d);//GGX
    float Vis_SmithV = dotNL * (dotNV * (1. - a) + a);
    float Vis_SmithL = dotNV * (dotNL * (1. - a) + a);
    float Vis = 0.5 / (Vis_SmithV + Vis_SmithL);// VIS = G / (4. * dotNV * dotNL)
    vec3 F0 = mix(vec3(0.16 * specular * specular), baseColor, metalness);
    vec3 F = F0 + (1. - F0) * (1. - dotHV) * (1. - dotHV) * (1. - dotHV) * (1. - dotHV) * (1. - dotHV);
    vec3 kD = (1. - F) * (1. - metalness);

    if (mID <= 1){
        shadowPass = calcSoftshadow(p, l, MIN_SHADOW_DIST, MAX_SHADOW_DIST);
    }

    vec3 color = vec3(1.);
    vec3 f = vec3(0.);

    if (u_diffusePassOn + u_specularPassOn > 0){
        if (u_diffusePassOn == 1){
            f += kD * baseColor / PI;
        }
        if (u_specularPassOn == 1){
            f += F * D * Vis;
        }
        color = PI * f * light.color * dotNL * 17. / falloffLength;
    }
    if (u_shadowPassOn == 0){
        return color;
    }
    else {
        return color * shadowPass;
    }
}

vec3 sceneRender(vec3 p, vec3 v, vec3 n, int mID, vec2 screen){
    vec3 color = vec3(AMBIENT_ALBEDO);
    for (int i = 0; i < NB_LIGHTS; ++i) {
        color += objectPBRLighting (lights[i], p, v, n, mID, screen);
    }
    return color;
}

void main(){

    srand(hash(int(u_widthHeight[0]*v_position.x) + hash(int(u_widthHeight[1]*v_position.y) + u_drawN)));

    vec3 color = vec3(0.);

    lights[0] = Light(vec3(-2.0, -4.0, 4.0)/1.4, vec3(1.0));
    lights[1] = Light(vec3(5.0, 2.0, 6.0)/1.7, vec3(1.0));

    vec2 o = (vec2(float(rand()), float(rand())) / 32767.0 - 0.5)/u_widthHeight[1]*2.;
    float screenX = (v_position.x+o.x)*u_widthHeight[0]/u_widthHeight[1];
    float screenY = v_position.y+o.y;
    vec3 v = -1. * normalize(u_trans_cam * vec3(screenX, screenY, u_cam_w));//vector from sample point to cam

    float midDepth = -2.;
    float minThreshold = 2.;
    int midN =0;
    PointInfo distMID;
    distMID = shortestDistanceToSurface(u_eye, v, MIN_DIST, MAX_DIST);//distance between cam and sample point

    if (distMID.sd > MAX_DIST-EPSILON){
        // Didn't hit anything
        color = vec3(0., 0., 0.);
    }
    else {
        vec3 p = u_eye - distMID.sd * v;// position of sample point
        vec3 n = calcNormal(p);//normal vector at the sample point
        color = sceneRender(p, v, n, distMID.materialID, vec2(screenX, screenY));
    }

    vec4 data = texture(samplerFB, 0.5 + 0.5 * v_position);
    if (u_drawN <= 0) {
        outputColor = vec4(color, 1.0);
    } else {
        outputColor = data + vec4(color, 1.0);
    }

}
</script>

<script id="fragment-shader-screen" type="x-shader/x-fragment">#version 300 es
precision highp float;

uniform sampler2D samplerFB;
in vec2 v_position;
out vec4 outputColor;

void main(){
    vec4 data = texture(samplerFB, 0.5 + 0.5 * v_position);
    outputColor = vec4(pow(data.xyz / data.w, vec3(0.8)), 1.0);
}
</script>


<script>
    "use strict";

    let vector3 = new webgl_vector3();
    let matrix3 = new webgl_matrix3();
    let canvas = document.getElementById('triangle');

    function sphereToCartesian(sphere) {
        return [sphere[0] * Math.sin(sphere[1] / 180 * Math.PI) * Math.cos(sphere[2] / 180 * Math.PI),
            sphere[0] * Math.sin(sphere[1] / 180 * Math.PI) * Math.sin(sphere[2] / 180 * Math.PI),
            sphere[0] * Math.cos(sphere[1] / 180 * Math.PI)];
    }

    function hexToRgb(hex) {
        return hex.match(/\w\w/g).map(x => parseInt(x, 16));
    }

    function compileShader(gl) {  //创建着色器
        const vShaderSource = document.getElementById('vertex-shader').text;
        const fShaderSource = document.getElementById('fragment-shader-frame-buffer').text;
        const fShaderScreenSource = document.getElementById('fragment-shader-screen').text;
        // import vShaderSource from '../lib/shader/draw_2d/draw_2d_vert.js';
        // import fShaderSource from '../lib/shader/draw_2d/draw_2d_frag.js';

        //编译和链接着色器
        return {
            programFB: initShader(gl, vShaderSource, fShaderSource),
            programScreen: initShader(gl, vShaderSource, fShaderScreenSource)
        };
    }

    function createBuffer(gl, {program}) {
        //创建缓冲区对象
        let buffer_id = gl.createBuffer();

        //将它绑定到ARRAY_BUFFER（将其视为ARRAY_BUFFER = buffer_id）
        //绑定缓冲区
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer_id);

        //三个顶点构成一个三角形
        let positions = [
            -1.0, -1.0, 1.0,
            -1.0, -1.0, 1.0,
            1.0, -1.0, 1.0,
            1.0, -1.0, 1.0
        ];

        //通过绑定点向缓冲区绑定数据
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

        //渲染

        //使画布的像素数和显示大小匹配
        // webglUtils.resizeCanvasToDisplaySize(gl.canvas);

        //设置视口
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

        //清除canvas
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);

        //应用着色器
        gl.useProgram(program);

        //在着色器中寻找attribute变量
        let a_position_location = gl.getAttribLocation(program, 'a_position');

        //建立着色器中attribute变量与缓冲区之间的连接
        gl.enableVertexAttribArray(a_position_location);

        const size = 2;//2维坐标：每次迭代运行提取两个单位数据
        const type = gl.FLOAT;//每个单位的数据类型是32位浮点型
        const normalize = false;//不需要归一化数据
        const stride = 0;//每次迭代前进大小* sizeof（类型）以获得下一个位置
        const offset1 = 0;//从缓冲起始位置开始读取

        //从缓冲区取出数据
        gl.vertexAttribPointer(a_position_location, size, type, normalize, stride, offset1);
    }

    function createAndSetupTexture(gl) {

        let texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);

        // Set up texture so we can render any size image and so we are
        // working with pixels.
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

        return texture;
    }


    function initialFrameBuffer(gl, status) {

        for (let ii = 0; ii < 2; ++ii) {
            let texture = createAndSetupTexture(gl);
            status.textures.push(texture);

            // make the texture the same size as the image
            gl.texImage2D(
                gl.TEXTURE_2D, 0, gl.RGBA32F, canvas.width, canvas.height, 0,
                gl.RGBA, gl.FLOAT, null);

            // Create a framebuffer
            let fbo = gl.createFramebuffer();
            status.frameBuffers.push(fbo);
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
            // Attach a texture to framebuffer.
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

            let e = gl.checkFramebufferStatus(gl.FRAMEBUFFER); //检查帧缓冲区对象是否被正确设置
            if (gl.FRAMEBUFFER_COMPLETE !== e) {
                console.log('Frame buffer object is incomplete: ' + e.toString());
            }
        }
    }

    function initialUniform(gl, status) {

        let program = status.program;
        let uLoc = { //register uniform variables
            //u_aspectRatio: gl.getUniformLocation(program, 'u_aspectRatio'),
            u_cam_w: gl.getUniformLocation(program, 'u_cam_w'),
            u_baseColor: gl.getUniformLocation(program, 'u_baseColor'),
            u_metalness: gl.getUniformLocation(program, 'u_metalness'),
            u_roughness: gl.getUniformLocation(program, 'u_roughness'),
            u_specular: gl.getUniformLocation(program, 'u_specular'),
            u_trans_cam: gl.getUniformLocation(program, 'u_trans_cam'),
            u_eye: gl.getUniformLocation(program, 'u_eye'),
            u_rotZAngle: gl.getUniformLocation(program, 'u_rotZAngle'),
            u_diffusePassOn: gl.getUniformLocation(program, 'u_diffusePassOn'),
            u_specularPassOn: gl.getUniformLocation(program, 'u_specularPassOn'),
            u_shadowPassOn: gl.getUniformLocation(program, 'u_shadowPassOn'),
            u_drawN: gl.getUniformLocation(program, 'u_drawN'),
            u_cuttingPlane: gl.getUniformLocation(program, 'u_cuttingPlane'),
            u_widthHeight: gl.getUniformLocation(program, 'u_widthHeight')
        };

        status.setMaterial = function (materialName) {
            return function () {
                gl.uniform1fv(uLoc["u_" + materialName], new Float32Array(status[materialName]));
            }
        }

        const materialList = ["roughness", "metalness", "specular"];
        materialList.forEach(function (materialName) {
            status.setMaterial(materialName)();
        });

        setCam(gl, uLoc, status);
        setRotZAngle(gl, uLoc, status);
        setDiffusePass(gl, uLoc, status);
        setSpecularPass(gl, uLoc, status);
        setShadowPass(gl, uLoc, status);
        setBaseColor(gl, uLoc, status);
        setCuttingPlane(gl, uLoc, status);

        let aspectRatio = gl.canvas.width / gl.canvas.height;
        //gl.uniform1f(uLoc.u_aspectRatio, aspectRatio);
        gl.uniform1fv(uLoc.u_widthHeight, new Float32Array([gl.canvas.width, gl.canvas.height]));

        const fieldOfView = 30.0;
        let cam_w = aspectRatio / 2. / Math.tan(fieldOfView / 360. * Math.PI);
        gl.uniform1f(uLoc.u_cam_w, cam_w);

        return uLoc;
    }

    function setCam(gl, {u_trans_cam, u_eye, u_drawN}, {cameraSphereCoor}) {
        let trans_cam = matrix3.camToWorld(90.0 - cameraSphereCoor[1], cameraSphereCoor[2]);
        gl.uniformMatrix3fv(u_trans_cam, false, trans_cam);

        let camera = vector3.createFrom(sphereToCartesian(cameraSphereCoor));  // Camera Position
        gl.uniform3fv(u_eye, camera);
    }

    function setCuttingPlane(gl, {u_cuttingPlane}, {cuttingPlane}) {
        gl.uniform1f(u_cuttingPlane, cuttingPlane);
    }

    function setRotZAngle(gl, {u_rotZAngle}, {rotZAngle}) {
        gl.uniform1f(u_rotZAngle, rotZAngle);
    }

    function setDiffusePass(gl, {u_diffusePassOn}, {diffusePassOn}) {
        gl.uniform1i(u_diffusePassOn, +diffusePassOn);
    }

    function setSpecularPass(gl, {u_specularPassOn}, {specularPassOn}) {
        gl.uniform1i(u_specularPassOn, +specularPassOn);
    }

    function setShadowPass(gl, {u_shadowPassOn}, {shadowPassOn}) {
        gl.uniform1i(u_shadowPassOn, +shadowPassOn);
    }

    function setBaseColor(gl, {u_baseColor}, {baseColor}) {
        gl.uniform3fv(u_baseColor, new Float32Array(baseColor.flat()));
    }

    function scaleElements(gl) {
        const canvasScale = 0.6;
        const aspectRatio = 1.5;
        canvas.width = Math.round(window.innerWidth * canvasScale);
        canvas.height = Math.round(canvas.width / aspectRatio);
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        document.getElementById("hue_container").style.transform = "scale(" + document.body.clientWidth / window.screen.width + ")";
    }

    function main() {
        //判断浏览器是否支持webgl， antialias用于设置抗锯齿，
        const gl = canvas.getContext('webgl2', {antialias: false, depth: false});
        if (!gl) {
            console.log("您的浏览器不支持WebGL2！请使用最新版本的Chrome浏览器");
            return null;
        }
        const ext = gl.getExtension("EXT_color_buffer_float");
        if (!ext) {
            alert("need EXT_color_buffer_float");
            return;
        }


        scaleElements(gl);

        const programs = compileShader(gl);

        const status = {  //maintains all the variables which may change at runtime
            program: programs.programFB,
            cameraSphereCoor: [3.0, 90.0, -90.0],  // (r,theta,phi) camera spherical coordinate
            rotZAngle: 0,
            isAnimated: false,
            stat: true,
            diffusePassOn: true,
            specularPassOn: true,
            shadowPassOn: true,
            baseColor: [[255 / 255, 255 / 255, 72 / 255], [108 / 255, 63 / 255, 175 / 255]],
            roughness: [0.3, 0.4],
            metalness: [0.0, 0.0],
            specular: [0.5, 0.5],
            textures: [],
            frameBuffers: [],
            drawN: 0,
            cuttingPlane: 0.3,

            toggleBool: function (boolName) {
                if (typeof this[boolName] === "boolean") {
                    this[boolName] = !this[boolName];
                    gl.useProgram(programs.programFB);
                    gl.uniform1i(uLoc["u_" + boolName], +this[boolName]);
                    gl.useProgram(this.program);
                }
            },

            redraw: function () {
                this.drawN = 0;
                gl.useProgram(programs.programFB);
                gl.uniform1i(uLoc.u_drawN, 0);
                gl.useProgram(this.program);
            },

            incrementDrawN: function () {
                ++this.drawN;
                gl.useProgram(programs.programFB);
                gl.uniform1i(uLoc.u_drawN, this.drawN);
                gl.useProgram(this.program);
            },

            updateUniformVec3: function (name, value) {
                gl.useProgram(programs.programFB);
                this[name] = value || this[name];
                gl.uniform3fv(uLoc["u_" + name], new Float32Array(this[name].flat()));
                gl.useProgram(this.program);
            },

            updateUniformFloatArray: function (name, value) {
                gl.useProgram(programs.programFB);
                this[name] = value || this[name];
                let input = typeof (this[name]) === "number" ? [this[name]] : this[name];
                gl.uniform1fv(uLoc["u_" + name], new Float32Array(input));
                gl.useProgram(this.program);
            },

            updateUniformFloat: function (name, value) {
                gl.useProgram(programs.programFB);
                this[name] = value || this[name];
                gl.uniform1f(uLoc["u_" + name], this[name]);
                gl.useProgram(this.program);
            }
        };

        createBuffer(gl, status);  //为Attribute变量创建buffer
        let uLoc = initialUniform(gl, status);  //绑定Uniform变量
        initialFrameBuffer(gl, status);

        //---------------------------------------------------------------------------------------------------

        initWindowEventHandles();
        initControlAreaEventHandles();
        initCanvasEventHandles(canvas);

        let stats = new Stats();
        stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom
        document.getElementById("stats").appendChild(stats.dom);

        let then = 0;
        let texture_idx = 0;
        const rotationSpeed = 30 * Math.PI / 180.;
        let FBsamplerFBLoc = gl.getUniformLocation(programs.programFB, 'samplerFB');
        let screenSamplerFBLoc = gl.getUniformLocation(programs.programScreen, 'samplerFB');

        gl.activeTexture(gl.TEXTURE0);  //associate texture units with texture objects
        gl.bindTexture(gl.TEXTURE_2D, status.textures[1]);

        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, status.textures[0]);

        function drawScene(now) {
            stats.begin();

            now *= 0.001;
            let deltaTime = now - then;
            then = now;
            if (now > 1 && status.isAnimated) {
                status.rotZAngle += rotationSpeed * deltaTime;
                status.updateUniformFloatArray("rotZAngle");
            }


            // Draw on the framebuffer
            status.program = programs.programFB;
            gl.useProgram(programs.programFB);

            createBuffer(gl, status); //为Attribute变量创建buffer
            setCam(gl, uLoc, status);

            gl.bindFramebuffer(gl.FRAMEBUFFER, status.frameBuffers[texture_idx]); //将frameBuffers[n]绑定为目前的窗口
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

            gl.activeTexture(gl.TEXTURE0 + 1 - texture_idx);  //activate a texture unit
            gl.bindTexture(gl.TEXTURE_2D, status.textures[1 - texture_idx]);  //bind texture object to the activated texture unit
            gl.uniform1i(FBsamplerFBLoc, 1 - texture_idx);  //upload the data in the texture unit to the sampler2D variable in the shader program

            gl.drawArrays(gl.TRIANGLES, 0, 6);//画图 primitiveType = gl.TRIANGLES; offset2 = 0; count = 6;

            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            gl.bindTexture(gl.TEXTURE_2D, null);

            //draw on the screen
            status.program = programs.programScreen
            gl.useProgram(status.program);//指定使用某套着色器程序

            createBuffer(gl, status); //为Attribute变量创建buffer

            gl.activeTexture(gl.TEXTURE0 + texture_idx);
            gl.bindTexture(gl.TEXTURE_2D, status.textures[texture_idx]);
            gl.uniform1i(screenSamplerFBLoc, texture_idx);

            gl.drawArrays(gl.TRIANGLES, 0, 6);//画图 primitiveType = gl.TRIANGLES; offset2 = 0; count = 6;

            texture_idx = 1 - texture_idx;
            if (!status.isAnimated) {
                status.incrementDrawN();
            }


            requestAnimationFrame(drawScene);

            stats.end();
        }

        requestAnimationFrame(drawScene);

        function initWindowEventHandles() {
            window.addEventListener("resize", resizeCanvas, false);

            function resizeCanvas() {
                scaleElements(gl);
                gl.useProgram(programs.programFB);
                gl.uniform1fv(uLoc["u_widthHeight"], new Float32Array([gl.canvas.width, gl.canvas.height]));
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, status.textures[0]);
                gl.texImage2D(
                    gl.TEXTURE_2D, 0, gl.RGBA32F, canvas.width, canvas.height, 0,
                    gl.RGBA, gl.FLOAT, null);
                gl.activeTexture(gl.TEXTURE0 + 1);
                gl.bindTexture(gl.TEXTURE_2D, status.textures[1]);
                gl.texImage2D(
                    gl.TEXTURE_2D, 0, gl.RGBA32F, canvas.width, canvas.height, 0,
                    gl.RGBA, gl.FLOAT, null);
                gl.useProgram(status.program);
                console.log(gl.canvas.width, gl.canvas.height);

                status.redraw();
            }
        }

        function initControlAreaEventHandles() {
            document.getElementById("animate").onclick = function () {
                status.toggleBool("isAnimated");
                status.redraw();
            }

            document.getElementById("diffuse").onclick = function () {
                status.toggleBool("diffusePassOn");
                status.redraw();
            }

            document.getElementById("specular").onclick = function () {
                status.toggleBool("specularPassOn");
                status.redraw();
            }

            document.getElementById("shadow").onclick = function () {
                status.toggleBool("shadowPassOn");
                status.redraw();
            }

            document.getElementById("stat").onclick = function () {
                status.stat = !status.stat;
                document.getElementById("stats").style.visibility = (status.stat) ? "visible" : "hidden";
            }

            $("#colorPicker").on("input", function () {
                status.baseColor[0] = hexToRgb($(this).val()).map(x => x / 255);
                status.updateUniformVec3("baseColor");
                status.redraw();
            });


            function UpdateMaterielStatus(elementID) {
                return function () {
                    $(elementID).val(this.value);
                    let materialName = elementID.slice(2).toLowerCase()
                    status[materialName][0] = this.value;
                    status.updateUniformFloatArray(materialName);
                    status.redraw();
                }
            }

            let patt = /^(0*\.\d*)|([01](.0*)?)$/;  //0,0.13,0.00,1.00,1,1.

            function inputMaterialInfo(elementID) {
                return function () {
                    let curValue = $.trim($(elementID).val());
                    let materialName = elementID.slice(2).toLowerCase();
                    if (patt.test(curValue)) {
                        let inputValue = status[materialName][0] = parseFloat(curValue);
                        $(elementID).val(inputValue);
                        $(elementID.replace('v', 's')).val(inputValue);
                        status.updateUniformFloatArray(materialName);
                        status.redraw();
                    } else {
                        $(elementID).val(status[materialName][0]);
                    }
                }
            }

            let re = /[a-zA-Z]+(?=[A-Z])/;

            function updateSlider(elementID) {
                return function () {
                    $(elementID).val(this.value);
                    let statusName = elementID.match(re)[0];
                    status[statusName] = this.value;
                    status.updateUniformFloat(statusName, this.value);
                    status.redraw();
                }
            }

            function updateText(elementID) {
                return function () {
                    let curValue = $.trim($(elementID).val());
                    let statusName = elementID.match(re)[0];
                    if (patt.test(curValue)) {
                        let inputValue = status[statusName] = parseFloat(curValue);
                        $(elementID).val(inputValue);
                        $(elementID.replace('Text', 'Slider')).val(inputValue);
                        status.updateUniformFloat(statusName, this.value);
                        status.redraw();
                    } else {
                        $(elementID).val(status[statusName]);
                    }
                }
            }

            let item = ["#vRoughness", "#vSpecular", "#vMetalness", "#cuttingPlaneText"];

            $("#sRoughness").on("change", UpdateMaterielStatus("#vRoughness"));  //Bind moving slider Events
            $("#sMetalness").on("change", UpdateMaterielStatus("#vMetalness"));
            $("#sSpecular").on("change", UpdateMaterielStatus("#vSpecular"));


            $("#cuttingPlaneSlider").on("change", updateSlider("#cuttingPlaneText"));
            $("#cuttingPlaneText").on("blur", updateText("#cuttingPlaneText"));

            $(item).each(function () {  //Bind Enter key events, blur the input area after pressing the Enter key
                $(this).on('keydown', function (event) {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        this.blur();
                    }
                });
            });

            $(item).each(function () {  //Bind input material info events
                $(this).on("blur", inputMaterialInfo(this));
            });
        }

        function initCanvasEventHandles(domElement) {
            let dragging = false;
            let lastX = -1;
            let lastY = -1;

            domElement.onmousedown = function (event) {
                event.preventDefault();

                // 鼠标点击位置
                let x = event.clientX;
                let y = event.clientY;
                lastX = x;
                lastY = y;
                dragging = true;
            }

            domElement.onmouseleave = function (event) {
                event.preventDefault();
                dragging = false;
            }

            // 鼠标抬起事件
            domElement.onmouseup = function (event) {
                event.preventDefault();
                dragging = false;
            }

            // 鼠标移动事件
            domElement.onmousemove = function (event) {
                event.preventDefault();
                let x = event.clientX, y = event.clientY;

                if (dragging) {
                    // 旋转比例--速度
                    let factor = 180.0;

                    // 限制 x轴的旋转角度 -90 --- 90
                    status.cameraSphereCoor[1] -= factor * (y - lastY) / domElement.height;
                    status.cameraSphereCoor[2] -= factor * (x - lastX) / domElement.width;
                    status.redraw();
                }
                lastX = x;
                lastY = y;
            }

            domElement.addEventListener('wheel', onMouseWheel, false);

            function onMouseWheel(event) {
                event.preventDefault();
                if (Math.abs(event.deltaY) > 0.00001) {
                    status.cameraSphereCoor[0] += event.deltaY * 0.003;
                    status.redraw();
                }
                event.cancelBubble = true;
                event.stopPropagation();
            }
        }
    }

    main();

</script>

</body>
</html>